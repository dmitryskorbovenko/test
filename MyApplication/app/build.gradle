apply plugin: 'com.android.application'

android {
    compileSdkVersion 25
    buildToolsVersion "25.0.3"
    defaultConfig {
        applicationId "com.example.dmitryskorbovenko.myapplication"
        minSdkVersion 15
        targetSdkVersion 25
        versionCode 1
        versionName inferVersion()
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
        exclude group: 'com.android.support', module: 'support-annotations'
    })
    compile 'com.android.support:appcompat-v7:25.3.1'
    compile 'com.android.support.constraint:constraint-layout:1.0.2'
    testCompile 'junit:junit:4.12'
}

task printVersion {
    doLast {
        println inferVersion()
    }
}

task rc {
    doLast {
        if (!isMasterBranch()) {
            throw new GradleException('$name: you MUST create RC from master branch')
        }

        if (isWcDirty()) {
            throw new GradleException('you have local changes')
        }

        if (isRcBranchExist()) {
            throw new GradleException("$name: you already have local RC branch")
        }

        if (!project.hasProperty('rc.version')) {
            throw new GradleException("$name: run: gradlew rc -Prc.version=1.0.0")
        }

        def version = project.property('rc.version')
        if (!(version ==~ /\d+\.\d+\.\d+/)) {
            throw new GradleException(name + ': rc.version parameter should comply regex /\\d+.\\d+.\\d+/ ')
        }

        exitOnFailure("git tag v$version-RC")
        exitOnFailure("git checkout -b RC")
        exitOnFailure("git push origin RC -u")
    }
}

task release {
    doLast {
        if (!isRcBranch()) {
            throw new GradleException('you MUST release from RC branch')
        }

        if (isWcDirty()) {
            throw new GradleException('you have local changes')
        }


        def releaseVersion = getLatestTag().find(/\d+\.\d+\.\d+/)
        exitOnFailure("git tag v$releaseVersion")
        exitOnFailure("git push --tags")
    }
}

private static String exitOnFailure(String cmd) {
    def process = new ProcessBuilder(['sh', '-c', cmd]).redirectErrorStream(true).start()
    def output = process.text
    if (process.waitFor() != 0) {
        throw new GradleException(output)
    }

    return output.trim()
}

private static String inferVersion() {

    def latestTag = getLatestTag()

    def latestTagHash = exitOnFailure("git rev-list -n 1 $latestTag")

    def isLatestTagRelease = latestTag ==~ /$\d+\.\d+\.\d+^/

    def currentHash = exitOnFailure("git rev-parse HEAD")

    def isOnReleaseCommit = isLatestTagRelease && latestTagHash == currentHash

    def isRcBranch = isRcBranch()

    def version = latestTag
    if (!isRcBranch) {
        version = version.replaceAll(/v(\d+)\.(\d+)\.(\d+)(.*)/, { all, major, minor, patch, suffix ->
            "$major.${!isOnReleaseCommit ? Integer.parseInt(minor) + 1 : minor}.$patch"
        })
    }

    if (!isOnReleaseCommit) {
        version += "-SNAPSHOT"
    }

    return version
}

private static String getLatestTag() {
    exitOnFailure("git describe --abbrev=0 --tags --match v* --first-parent")
}

private static Boolean isRcBranch() {
    return getCurrentBranchName().contains("RC")
}

private static Boolean isRcBranchExist() {
    return "git rev-parse --verify RC".execute().waitFor() == 0
}

private static Boolean isMasterBranch() {
    return getCurrentBranchName() == "master"
}

private static String getCurrentBranchName() {
    return exitOnFailure("git rev-parse --abbrev-ref HEAD")
}

private static boolean isWcDirty() {
    return "git diff-index --quiet HEAD --".execute().waitFor() != 0
}